#ifndef UTILS_NUMBERTHEORY_NUMBER_FIELD_HPP_
#define UTILS_NUMBERTHEORY_NUMBER_FIELD_HPP_

#include <memory>

#include "numbertheory/numbertheory_fwd_types.hpp"

#include "cxx_mpz.hpp"
#include "mpz_poly.h"
#include "mpz_mat.h"
#include <string>

class number_field {
    cxx_mpz_poly f;
    cxx_mpz_poly f_hat;
    mutable std::unique_ptr<number_field_order> cached_maximal_order;
    mutable std::unique_ptr<cxx_mpq_mat> cached_trace_matrix;
    public:
    std::string name, varname;
    number_field(cxx_mpz_poly const& f);
    inline cxx_mpz_poly const& defining_polynomial() const { return f; }
    int degree() const { return defining_polynomial().degree(); }
    number_field_element gen() const;
    number_field_element operator()(cxx_mpz_poly const &, cxx_mpz const & =1) const;
    number_field_element operator()(cxx_mpz_mat const &, cxx_mpz const & =1) const;
    number_field_element operator()(cxx_mpq_mat const &) const;
    void bless(const char * name, const char * varname = NULL);
    void bless(std::string const & name, std::string const & varname);
    void bless(std::string const & name);
    number_field_order equation_order() const;
    number_field_order p_maximal_order(cxx_mpz const & p) const;

    /* return the order generated by this element, which must be integral */
    number_field_order order(number_field_element const & a) const;

    number_field_order const& maximal_order(unsigned long prime_limit=0) const;
    cxx_mpq_mat trace_matrix() const;
};

namespace fmt {
    template <> struct formatter<number_field> : formatter<string_view>{
        auto format(number_field const & K, format_context& ctx) const -> format_context::iterator {
            return fmt::format_to(ctx.out(), "Number Field {} in variable {} defined by {}", K.name, K.varname, K.defining_polynomial());
        }
    };
}
inline std::ostream& operator<<(std::ostream& os, number_field const & K) { return os << fmt::format("{}", K); }


#endif	/* UTILS_NUMBERTHEORY_NUMBER_FIELD_HPP_ */
